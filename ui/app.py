from flask import Flask, render_template, request, jsonify
from pathlib import Path
import subprocess
import base64
from io import BytesIO
import pandas as pd
import pyarrow.parquet as pq
import numpy as np
from matplotlib.figure import Figure

app = Flask(__name__)

source_path = Path(__file__).resolve()
source_dir = source_path.parent
root_dir = source_dir.parent

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/run_self_test', methods=['POST'])
def run_self_test():
    self_test_cmd = root_dir / "scripts" / "self_test.sh"
    try:
        result = subprocess.check_output(str(self_test_cmd), shell=True, text=True)
        return jsonify({'result': result, 'success': True})
    except subprocess.CalledProcessError as e:
        return jsonify({'result': f"Error: {e}", 'success': False})

@app.route('/receive_udp', methods=['POST'])
def receive_udp():
    local_ip = request.form.get('localIP')
    local_port = request.form.get('localPort')
    remote_ip = request.form.get('remoteIP')
    remote_port = request.form.get('remotePort')
    timeout = request.form.get('timeout')

    # First save config to file
    config_path = root_dir / "ui" / "tmp" / "cfg.yml"
    with open(config_path, 'w') as f:
        f.write("# Automatically generated by M2C UDP Process Web UI.\n")
        f.write("# Do not edit this file manually.\n")
        f.write(f"receive:\n")
        f.write(f"  local:\n")
        f.write(f"    ip: {local_ip}\n")
        f.write(f"    port: {local_port}\n")
        f.write(f"  remote:\n")
        f.write(f"    ip: {remote_ip}\n")
        f.write(f"    port: {remote_port}\n")
        f.write(f"  timeout: {timeout}\n")

    # Run C++ program to receive UDP data
    cpp_program = root_dir / "bin" / "m2c-udp-process"
    command = f"{cpp_program} r {config_path} -V"

    # Return JSON result (change this to something more useful),
    # including result and success flag
    try:
        result = subprocess.check_output(command, shell=True, text=True)
        return jsonify({'result': result, 'success': True})
    except subprocess.CalledProcessError as e:
        return jsonify({'result': f"Error: {e}", 'success': False})

@app.route('/plot', methods=['POST'])
def plot():
    plot_index = int(request.form.get('plotIndex'))
    parquet_file = pq.ParquetFile(root_dir / "test1.parquet")

    total_rows = 0  # Initialize a variable to count total rows

    # TODO: Number of rows come from C++ program

    try:
        # Iterate through the row groups and accumulate the total row count
        for row_group_index in range(parquet_file.num_row_groups):
            row_group = parquet_file.metadata.row_group(row_group_index)
            total_rows += row_group.num_rows

            # Check if the plot_index is within the current row group
            if plot_index < total_rows:
                # Calculate the relative index within the current row group
                relative_index = plot_index - (total_rows - row_group.num_rows)
                # Read the specific row group
                row_group_data = parquet_file.read_row_group(row_group_index)
                # Extract the specific row within the row group
                row_data = row_group_data.to_pandas().iloc[[relative_index]]
                CIR = np.uint32(row_data.iloc[0, 2:258])
                CIR_I = []
                CIR_Q = []
                for i in range(0, 256):
                    # Extract the 16-bit signed integer I and Q components from the 32-bit value
                    Q_component = np.int16(CIR[i] & 0xffff)  # Mask the lower 16 bits
                    I_component = np.int16((CIR[i] >> 16) & 0xFFFF)     # Shift and mask the higher 16 bits
                    CIR_I.append(I_component)
                    CIR_Q.append(Q_component)
                CIR_abs = np.sqrt(np.square(np.int64(CIR_I)) + np.square(np.int64(CIR_Q)))
                # Plot the CIR
                # Fig. 1: CIR I/Q
                fig1 = Figure(figsize=(8, 3.5))  # Adjust the figure size (width, height) as needed
                buf1 = BytesIO()
                ax = fig1.subplots()
                ax.plot(CIR_I, label='I')
                ax.plot(CIR_Q, label='Q')
                ax.set_xlim(0, 255)
                ax.grid(True)
                ax.set_xlabel('Sample Index')
                ax.set_ylabel('Amplitude')
                ax.legend()
                fig1.tight_layout()
                fig1.savefig(buf1, format="svg")
                data1 = buf1.getvalue().decode("utf-8")
                fig1_str = f"<div class=\"figure-container\">{data1}</div>"
                # Fig. 2: CIR abs
                fig2 = Figure(figsize=(8, 3.5))
                buf2 = BytesIO()
                ax = fig2.subplots()
                ax.stem(CIR_abs, markerfmt=' ')
                ax.set_xlim(0, 255)
                ax.grid(True)
                fig2.tight_layout()
                fig2.savefig(buf2, format="svg")
                data2 = buf2.getvalue().decode("utf-8")
                fig2_str = f"<div class=\"figure-container\">{data2}</div>"
                # Fig. 3: CIR abs (dB)
                fig3 = Figure(figsize=(8, 3.5))
                buf3 = BytesIO()
                ax = fig3.subplots()
                ax.stem(20 * np.log10(np.maximum(CIR_abs, 1)), markerfmt=' ')
                ax.set_xlim(0, 255)
                ax.grid(True)
                fig3.tight_layout()
                fig3.savefig(buf3, format="svg")
                data3 = buf3.getvalue().decode("utf-8")
                fig3_str = f"<div class=\"figure-container\">{data3}</div>"
                # Return JSON result (change this to something more useful),
                # including result and success flag
                return jsonify({'success': True, 'fig1': fig1_str, 'fig2': fig2_str, 'fig3': fig3_str})
        return jsonify({"error": f"Index {plot_index} not found"}), 404
    except Exception as e:
        return jsonify({"error": f"Plot error ({e})."}), 500

if __name__ == '__main__':
    app.run(debug=True)
